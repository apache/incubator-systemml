#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

/*
 * 2D Transpose convolutional layer.
 *
 * Utilizes built-in convolution operators for higher performance.
 */
 
forward = function(matrix[double] X, matrix[double] W, matrix[double] b,
                   int C, int Hin, int Win, int Hf, int Wf,
		           int strideh, int stridew, int padh, int padw,
		           int out_padh, int out_padw)
    return (matrix[double] out, int Hout, int Wout){
  /*
   * Computes the forward pass for a 2D spatial transpose convolutional 
   * layer with F filters.  The input data has N examples, each represented
   * as a 3D tensor flattened into a single vector.
   *
   * Inputs:
   *  - X: Inputs, of shape (N, C*Hin*Win).
   *  - W: Weights, of shape (F, C*Hf*Wf).
   *  - b: Biases, of shape (F, 1).
   *  - C: Number of input channels (dimensionality of depth).
   *  - Hin: Input height.
   *  - Win: Input width.
   *  - Hf: Filter height.
   *  - Wf: Filter width.
   *  - strideh: Stride over height.
   *  - stridew: Stride over width.
   *  - padh: Padding for top and bottom sides.
   *  - padw: Padding for left and right sides.
   *  - out_padh: extra padding for top side. This should 
   *      lie in [0, strideh-1].
   *  - out_padw: extra padding for right side. This should
   *      lie in [0, stridew-1].
   *
   * Outputs:
   *  - out: Outputs, of shape (N, F*Hout*Wout).
   *  - Hout: Output height.
   *  - Wout: Output width.
   */
  N = nrow(X)
  F = nrow(W)
  Hout = strideh * (Hin-1) - 2*padh + Hf + out_padh
  Wout = stridew * (Win-1) - 2*padw + Wf + out_padw

  out = conv2d_backward_data(W, X, stride=[strideh,stridew], padding=[padh,padw],
                             input_shape=[N,C,Hout,Wout], filter_shape=[F,C,Hf,Wf])

  out = bias_add(out, b)
}

backward = function(matrix[double] dout, int Hout, int Wout,
                    matrix[double] X, matrix[double] W, matrix[double] b,
                    int C, int Hin, int Win, int Hf, int Wf,
                    int strideh, int stridew, int padh, int padw)
    return (matrix[double] dX, matrix[double] dW, matrix[double] db){
  /*
   * Computes the backward pass for a 2D spatial transpose convolutional
   * layer with F filters.
   *
   * Inputs:
   *  - dout: Gradient wrt `out` from upstream, of
   *      shape (N, F*Hout*Wout).
   *  - Hout: Output height.
   *  - Wout: Output width.
   *  - X: Inputs, of shape (N, C*Hin*Win).
   *  - W: Weights, of shape (F, C*Hf*Wf).
   *  - b: Biases, of shape (F, 1).
   *  - C: Number of input channels (dimensionality of depth).
   *  - Hin: Input height.
   *  - Win: Input width.
   *  - Hf: Filter height.
   *  - Wf: Filter width.
   *  - strideh: Stride over height.
   *  - stridew: Stride over width.
   *  - padh: Padding for top and bottom sides.
   *  - padw: Padding for left and right sides.
   *
   * Outputs:
   *  - dX: Gradient wrt `X`, of shape (N, C*Hin*Win).
   *  - dW: Gradient wrt `W`, of shape (F, C*Hf*Wf).
   *  - db: Gradient wrt `b`, of shape (F, 1).
   */
  N = nrow(X)
  F = nrow(W)

  dW = conv2d_backward_filter(dout, X, stride=[strideh,stridew], padding=[padh,padw],
                              input_shape=[N,C,Hout,Wout], filter_shape=[F,C,Hf,Wf])

  dX = conv2d(dout, W, input_shape=[N,C,Hout,Wout], filter_shape=[F,C,Hf,Wf],
              stride=[strideh,stridew], padding=[padh,padw])

  db = rowSums(matrix(colSums(dout), rows=F, cols=Hout*Wout))
}

init = function(int F, int C, int Hf, int Wf)
    return (matrix[double] W, matrix[double] b){
  /*
   * Utility function to initialize the parameters of this layer.
   *
   * We use the heuristic by He et al., which limits the magnification
   * of inputs/gradients during forward/backward passes by scaling
   * unit-Gaussian weights by a factor of sqrt(2/n), under the
   * assumption of relu neurons.
   *  - http://arxiv.org/abs/1502.01852
   *
   * Inputs:
   *  - F: Number of filters.
   *  - C: Number of input channels (dimensionality of depth).
   *  - Hf: Filter height.
   *  - Wf: Filter width.
   *
   * Outputs:
   *  - W: Weights, of shape (F, C*Hf*Wf).
   *  - b: Biases, of shape (F, 1).
   */
  W = rand(rows=F, cols=C*Hf*Wf, pdf="normal") * sqrt(2/(C*Hf*Wf))
  b = matrix(0, rows=F, cols=1)
}

init_bilinear = function(int C, int K)
    return (matrix[double] W, matrix[double] b){
  /*
   * Utility function to upsample using this layer.
   *
   * Upsampling the input by factor f (each side) requires
   * channel-wise independent kernels of size K = 2f - f%2,
   * stride = f and pad = ceil((f-1)/2). The weights are set
   * via bilinear interpolation, bias is set to 0.
   * 
   * Inputs:
   *  - C: Number of input channels (dimensionality of depth).
   *  - K: Kernel size (upsampling requires a square filter
   *      of size K X K).
   *
   * Outputs:
   *  - W: Weights, of shape (F, C*Hf*Wf).
   *  - b: Biases, of shape (F, 1).
   */
  factor_up = ceil(K / 2)
  center = (2 * factor_up - factor_up %% 2 - 1) / 2 / factor_up
  vect = 1 - abs(seq(0, K-1) / factor_up - center)
  weights = matrix(vect %*% t(vect), rows=1, cols=K*K)

  if(C > 1){
    repl_weights = matrix(1, rows=C, cols=1) %*% cbind(weights, matrix(0, rows=1, cols=C*K*K))
    repl_weights_row = matrix(repl_weights, rows=1, cols=C*(C+1)*K^2)
    W = matrix(repl_weights_row[1,1:(C*K)^2], rows=C, cols=C*K^2)
  }else W = weights

  b = matrix(0, rows=C, cols=1)
}
