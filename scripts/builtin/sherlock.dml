#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------
source("scripts/builtin/sherlockNet.dml") as sherlockNet


# Frame[] load_file (Input: csv)
# Rows and columns index from 1. (-.-)
# no variables are possible to define the filepath of the read() function
# every *.csv file needs a *.csv.mtd file with following content:
#{
#  "data_type": "frame",
#  "value_type": "string",
#  "format": "csv",
#  "header": true,
#  "sep": ",",
#  "author": "local",
#  "created": "2020-12-07 00:00:01 UTC"
#}

######################################################
# methods to load and transform the data
######################################################

/*
 * Function to transform processed X values from the original sherlock project to
 * valid input for sherlock X input matrices.
 */
transform_values = function(frame[string] data) return (matrix[double] m_data) {

  rows = nrow(data)
  cols = ncol(data)
  data = data[1:rows,2:cols]

  #replace True/Fasle with 1/0
  data = map(data, "d -> d.replace(\"True\",\"1\")")
  data = map(data, "d -> d.replace(\"False\",\"0\")")
  m_data = as.matrix(data)
}

/*
 * Function to encode the string labels from the original sherlock project (y data)
 * to a numerical representation.
 *
 * Transform spec file should have the following content:
 *     { "recode":[ "label" ] }
 * where label is the column with containing the labels of the data
 */
transform_encode_labels = function(frame[string] data, string transform_spec)
    return (matrix[double] ground_truth , frame[string] meta_data) {

  rows = nrow(data)
  cols = ncol(data)

  #replace label with number
  [m_data, meta_data] = transformencode(target=data[1:rows,2:cols],
    spec=transform_spec)

  #print(toString(m_data[2]))
  ground_truth = matrix(0, rows=rows, cols=78)
  for ( i in 1:rows) {
    ground_truth[i, as.scalar(m_data[i,1])] = 1
  }
}

/*
 * Use the encoding from transform_encode_labels() to transform y labels to a numerical representation.
 */
transform_apply_labels = function(frame[string] data, frame[string] meta_data, string transform_spec) return (matrix[double] ground_truth) {
  #remove index row
  rows = nrow(data)
  cols = ncol(data)

  #replace label with number
  m_data = transformapply(target=data[1:rows,2:cols],
                  spec=transform_spec,
                  meta=meta_data)

  ground_truth = matrix(0, rows=rows, cols=78)
  for ( i in 1:rows) {
    ground_truth[i, as.scalar(m_data[i,1])] = 1
  }
}

transform_labels_to_ground_truth = function(matrix[double] data)
  return(matrix[double] ground_truth) {

  rows = nrow(data)
  ground_truth = matrix(0, rows=rows, cols=78)
  for ( i in 1:rows) {
    ground_truth[i, as.scalar(data[i,1])] = 1
  }
}

##########################################################
# training and testing of sherlock
##########################################################

/*
  data preprocessed: global stats, char dist, word embeddings, par vec
  ncols:             27, 960, 200 + 1, 400
*/
m_sherlock = function (matrix[double] A) return (double m) {
  #TODO: not sure if it is possible to write a builtin function
  m = sum(A)/nrow(A)
}

train = function(matrix[double] X_train, matrix[double] y_train)
      return (matrix[double] cW1, matrix[double] cb1,
            matrix[double] cW2, matrix[double] cb2,
            matrix[double] cW3, matrix[double] cb3,
            matrix[double] wW1, matrix[double] wb1,
            matrix[double] wW2, matrix[double] wb2,
            matrix[double] wW3, matrix[double] wb3,
            matrix[double] pW1, matrix[double] pb1,
            matrix[double] pW2, matrix[double] pb2,
            matrix[double] pW3, matrix[double] pb3,
            matrix[double] rW1, matrix[double] rb1,
            matrix[double] rW2, matrix[double] rb2,
            matrix[double] rW3, matrix[double] rb3,
            matrix[double] fW1, matrix[double] fb1,
            matrix[double] fW2, matrix[double] fb2,
            matrix[double] fW3, matrix[double] fb3) {
  train_cols = ncol(X_train)
  train_rows = nrow(X_train)
  [cW1, cb1, cW2, cb2, cW3, cb3] = sherlockNet::train(X_train[1:train_rows, 224:1183], y_train, 300)
  [wW1, wb1, wW2, wb2, wW3, wb3] = sherlockNet::train(cbind(X_train[1:train_rows, 13:212], X_train[1:train_rows, 1188]), y_train, 200)
  [pW1, pb1, pW2, pb2, pW3, pb3] = sherlockNet::train(X_train[1:train_rows, 1189:1588], y_train, 400)
  # better without Rest probs - validation 10000 lines: 0.4287 vs 0.4382
  [rW1, rb1, rW2, rb2, rW3, rb3] = sherlockNet::train(cbind(X_train[1:train_rows, 1:12], X_train[1:train_rows, 213:223], X_train[1:train_rows, 1184:1187]), y_train, 80)

  # train features seperate
  cprobs = sherlockNet::predict(X_train[1:train_rows, 224:1183], cW1, cb1, cW2, cb2, cW3, cb3)
  wprobs = sherlockNet::predict(cbind(X_train[1:train_rows, 13:212], X_train[1:train_rows, 1188]), wW1,wb1, wW2, wb2, wW3, wb3)
  pprobs = sherlockNet::predict(X_train[1:train_rows, 1189:1588], pW1, pb1, pW2, pb2, pW3, pb3)
  rprobs = sherlockNet::predict(cbind(X_train[1:train_rows, 1:12], X_train[1:train_rows, 213:223], X_train[1:train_rows, 1184:1187]), rW1, rb1, rW2, rb2, rW3, rb3)

  #use trained features to train final net
  first_predictions = cbind(cprobs, wprobs, pprobs, rprobs)
  [fW1, fb1, fW2, fb2, fW3, fb3] = sherlockNet::train(first_predictions, y_train, 500)
}

predict = function(matrix[double] X,
            matrix[double] cW1, matrix[double] cb1,
            matrix[double] cW2, matrix[double] cb2,
            matrix[double] cW3, matrix[double] cb3,
            matrix[double] wW1, matrix[double] wb1,
            matrix[double] wW2, matrix[double] wb2,
            matrix[double] wW3, matrix[double] wb3,
            matrix[double] pW1, matrix[double] pb1,
            matrix[double] pW2, matrix[double] pb2,
            matrix[double] pW3, matrix[double] pb3,
            matrix[double] rW1, matrix[double] rb1,
            matrix[double] rW2, matrix[double] rb2,
            matrix[double] rW3, matrix[double] rb3,
            matrix[double] fW1, matrix[double] fb1,
            matrix[double] fW2, matrix[double] fb2,
            matrix[double] fW3, matrix[double] fb3)
      return (matrix[double] probs) {

  rows = nrow(X)

  cprobs = sherlockNet::predict(X[1:rows, 224:1183], cW1, cb1, cW2, cb2, cW3, cb3)
  wprobs = sherlockNet::predict(cbind(X[1:rows, 13:212], X[1:rows, 1188]), wW1,wb1, wW2, wb2, wW3, wb3)
  pprobs = sherlockNet::predict(X[1:rows, 1189:1588], pW1, pb1, pW2, pb2, pW3, pb3)
  rprobs = sherlockNet::predict(cbind(X[1:rows, 1:12], X[1:rows, 213:223], X[1:rows, 1184:1187]), rW1, rb1, rW2, rb2, rW3, rb3)

  first_predictions = cbind(cprobs, wprobs, pprobs, rprobs)
  #final training
  probs = sherlockNet::predict(first_predictions, fW1, fb1, fW2, fb2, fW3, fb3)
}

eval = function(matrix[double] probs, matrix[double] Y)
  return (double loss, double accuracy, double f1, double precision, double recall) {
  /*
  * Evaluates the performance of the network.
  *
  * The probs matrix contains the class probability predictions
  * of K classes over N examples. The targets, Y, have K classes,
  * and are one-hot encoded.
  *
  * Inputs:
  *  -probs: Class probabilities, of shape(N, K).
  *  - Y: Target matrix, of shape (N, K).
  *
  * Outputs:
  *  - loss: Scalar loss, of shape (1).
  *  - accuracy: Scalar accuracy, of shape(1).
  */
  [loss, accuracy, f1, precision, recall] = sherlockNet::eval(probs, Y)
}






