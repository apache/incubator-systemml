print("STARTING STABLE MARRIAGE");
print("booooooooooooooooooooom");
#TODO set a finite number of maximum iterations so that the execution termiates after maximum iterations.
fileRR = ifdef ($RR, "");
fileHH = ifdef ($HH, "");
fileCC = ifdef ($CC, "");
fileOutput = ifdef ($OUT, "");
ordered = ifdef ($ordered, TRUE);
R = read (fileRR);
H= read (fileHH);
C = read (fileCC);




print("\n")
print("STARTING STABLE MARRIAGE");
print("READING P AND A...");


m = nrow(R)
n = ncol (R)

print("M    and   N...");
print(toString(m))
print(toString(n))
################################################################
Capacity = matrix(0.0, rows=3, cols=1)
print(toString(Capacity))
print(toString(C))
Capacity = C;

ResidencyMatch = matrix(0.0, rows=m, cols=n)
HospitalMatch = matrix(0.0, rows=n, cols=m)


#########################################################################################################
# Check that no Residents is matched to an unacceptable Hospitals. """
#########################################################################################################

#check_Residence_unhappy(Residence, Hospital):
#""" Determine whether a Residence is unhappy because they are unmatched, or
#they prefer the Hospital to their current match. """

#########################################################################################################
# Set all residents to be unmatched, and  """ all hospitals to be totally unsubscribed.
############################################################################################################333333
#      1. Take any unmatched resident with a non-empty preference list,
#     :math:`r`, and consider their most preferred hospital, :math:`h`. Match
#    them to one another.
#
#       2. If, as a result of this new matching, :math:`h` is now
#      over-subscribed, find the worst resident currently assigned to
#     :math:`h`, :math:`r'`. Set :math:`r'` to be unmatched and remove them
#    from :math:`h`'s matching. Otherwise, go to 3.
#
#       3. If :math:`h` is at capacity (fully subscribed) then find their worst
#      current match :math:`r'`. Then, for each successor, :math:`s`, to
#     :math:`r'` in the preference list of :math:`h`, delete the pair
#    :math:`(s, h)` from the game. Otherwise, go to 4.
#
#       4. Go to 1 until there are no such residents left, then end.
###############################################################################################33



Result_matrix = matrix(0.0, rows=nrow(R), cols=ncol(R))

if(nrow(Capacity) != nrow(H)) {
  print("ERROR: Wrong Input !Capacity indexes is not match with the Number of hospitals ")
  #it means that some hospitals' capacity is not defined.
}# end of if
# in this step we consider that  Residents Matrix is ORDERED   !!!!
# in this step we consider that  Hospital  Matrix is UNORDERED !!!!
######### we check if the hospital has the cepacity and also resident i has the high preference to match hospital so the Hopotalmatch will be OK for resident i #########
######### scalar (R[i,j]) in Hospital number (we consider that residency matrix in ORDERED)---------------------------------------------------------------------#########

prev_Residents_vector = rowMins(HospitalMatch)
prevIndex_Residents_vector =  rowIndexMin(HospitalMatch)

prev1_best_Residents = rowMins(Result_matrix)
# print(toString(prev_Residents_vector))

S = diag(matrix(1.0, rows=m, cols=1))  ### for checking while
HIndex =matrix(1.0, rows=m, cols=1)
proposer_pointers = matrix(1.0, rows=m, cols=1)
prev_Residents_vector = matrix(1.0, rows=n, cols=1)
prevIndex_Residents_vector = matrix(1.0, rows=n, cols=1)

kk =0

while(sum(S) > 0) {

  Stripped_preferences = S %*% R
  Mask_matrix = matrix(0.0, rows=n, cols=m)
  print("toString(Stripped_preferences)---------------------------------------")
  print(toString(Stripped_preferences))

  parfor(i in 1:m) {
    max_proposal = as.scalar(Stripped_preferences[i, as.scalar(proposer_pointers[i])])

    print("@@@@@@@@@@@@@@@@@@@@@@@@@toString(Stripped_preferences)")
    print(toString(Stripped_preferences))
    if(max_proposal != 0) {

      proposer_pointers[i] = as.scalar(proposer_pointers[i]) + 1
     # if (as.scalar(proposer_pointers[i]) > n){
      #  proposer_pointers[i] = n
      #}
      Mask_matrix[max_proposal, i] = 1    #########it means that later check that is hospital also wants this resident or not
      print("as.scalar(proposer_pointers[i])   111111111111100000000000000000000000000000000000000000000000000000000000000111111111111")
      print(toString(as.scalar(proposer_pointers[i])))
    }

  }


  parfor(i in 1:m, check=0) {
    SecondIndex = as.scalar (proposer_pointers[i])
    print("SecondIndex")
    print(toString( SecondIndex))

    HIndex[i] = as.scalar (R[i,SecondIndex])
    prev_Residents_vector = rowMaxs(HospitalMatch)
    prevIndex_Residents_vector =  rowIndexMax(HospitalMatch)


    if (as.scalar(HIndex[i]) != 0 ){

      X = as.scalar (H[as.scalar (HIndex[i]),i])
      if (X > 0){

        if (as.scalar (Capacity[as.scalar (HIndex[i]),1]) >= 1){


          Capacity[as.scalar (HIndex[i]),1] = as.scalar (Capacity[as.scalar (HIndex[i]),1]) -1
          ResidencyMatch [i,as.scalar (HIndex[i])] = SecondIndex
          HospitalMatch [as.scalar (HIndex[i]), i] = SecondIndex
          #Disable freshly Matched resident to search for a new Hospital in the next round
          S[i, i] = 0
          #   proposer_pointers[i] = as.scalar(proposer_pointers[i]) + 1
          #                   if (as.scalar(proposer_pointers[i]) > n){
          #                     proposer_pointers[i] = n
          #                }
          print("*************as.scalar (Capacity[as.scalar (HIndex[i])*********1111111111*****");
          print(toString(as.scalar (Capacity[as.scalar (HIndex[i]),1])));
        }# end of if HIndex




         if  (as.scalar (Capacity[as.scalar (HIndex[i]),1]) < 1){
          print("*************as.scalar (Capacity[as.scalar (HIndex[i])**** 2222222222222**********");

          if   ((as.scalar (prev_Residents_vector[as.scalar (HIndex[i])]))>= SecondIndex  ){
            print("*************as.scalar (Capacity[as.scalar (HIndex[i])**** 33333333333333333333332**********");


            ##### in this step we check that if the hospital capacity is 0 but the preference value of  prev residents is lower than the preference value of current resident #######
            ##### we should replace the prev resident with current resident----------------------------------------------------------------------------------------------------#######
            HXX= as.scalar(prevIndex_Residents_vector[as.scalar (HIndex[i]),1])#############which prev resident
            HospitalMatch [as.scalar (HIndex[i]) ,HXX] = 0
            ResidencyMatch[HXX,as.scalar (HIndex[i])] = 0
            HospitalMatch [as.scalar (HIndex[i]),i ] = as.scalar (proposer_pointers[i])
            ResidencyMatch [i,as.scalar (HIndex[i])] = as.scalar (proposer_pointers[i])
            S[i, i] = 0
            MM =as.scalar(prevIndex_Residents_vector[as.scalar (HIndex[i]),1])
            if(MM > 0){

              print("*************(MM > 0)**********");

              S[MM,MM] = 1
              proposer_pointers[i] = as.scalar(proposer_pointers[i]) + 1
              if (as.scalar(proposer_pointers[i]) > n){
                proposer_pointers[i] = n
              }
            }# end of  if(MM > 0)

          }# end of checking secondIndex
        }## end of else if
      } #end of if X
    }# end of if   if (as.scalar(HIndex[i])
    #  new_best_proposer_index = i
    # #################If ?????#############I should check again


    print(toString(S))


  } ##  end of for (i 1:m)
    kk = kk+1
    print("toString(kk")
print(toString(kk))

}   # end of while
Result_matrix = ResidencyMatch
print("Result: ")
print(toString(ResidencyMatch))
print(toString(HospitalMatch))
if(fileOutput != "")
  write(R, fileOutput)