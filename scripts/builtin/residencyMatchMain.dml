#-------------------------------------------------------------
## Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
##-------------------------------------------------------------
# THIS SCRIPT COMPUTES A SOLUTION FOR THE HOSPITAL RESIDENCY MATCH PROBLEM
#
# INPUT PARAMETERS:
# --------------------------------------------------------------------------------------------
# NAME                  TYPE       DEFAULT      MEANING
# --------------------------------------------------------------------------------------------
# R                     Matrix     ---          Residents matrix R.
#                                               It must be an ORDERED  matrix.
#
# H                     Matrix     ---          Hospitals matrix H.
#                                               It must be an UnORDERED matrix.
#
# C                     Matrix     ---          Capacity of Hospitals matrix C.
#                                               It must be a [c,1] matrix with non zero values.
#                                               i.e. the leftmost value in a row is the most preferred partner's index.
#                                               i.e. the leftmost value in a row in P is the preference value for the acceptor with index 1 and vice-versa (higher is better).
# OUTPUT PARAMETERS:
# --------------------------------------------------------------------------------------------
# NAME                  TYPE       DEFAULT      MEANING
# --------------------------------------------------------------------------------------------
# ResidencyMatch        Matrix     ---          Result Matrix
#                                               If cell [i,j] is non-zero, it means that Resident i has matched with Hospital j.
#                                               Further, if cell [i,j] is non-zero, it holds the preference value that led to the match.
#
#
# HospitalMatch         Matrix     ---          Result Matrix
#                                               If cell [i,j] is non-zero, it means that Resident i has matched with Hospital j.
#                                               Further, if cell [i,j] is non-zero, it holds the preference value that led to the match.
#
#
# Residents.mtx:
# 2.0,1.0,3.0
# 1.0,2.0,3.0
# 1.0,2.0,0.0
#
# Since it is an ORDERED  matrix, this means that Resident 1 (row 1) likes acceptor 2 the most, followed by acceptor 1 and acceptor 3.
# If it was UNORDERED, this would mean that proposer 1 (row 1) likes acceptor 3 the most (since the value at [1,3] is the row max),
# followed by acceptor 1 (2.0 preference value) and acceptor 2 (1.0 preference value).
#
# Hospitals.mtx:
# 2.0,1.0,0.0
# 0.0,1.0,2.0
# 1.0,2.0,0.0
#
# Since it is an UNORDERED matrix this means that Hospital 1 (row 1) likes Resident 1 the most (since the value at [1,1] is the row max).
#
# Capacity.mtx
# 1.0
# 1.0
# 1.0
#
# ResidencyMatch.mtx
# 0.0,0.0,3.0
# 1.0,0.0,0.0
# 0.0,2.0,0.0
#
# HospitalMatch.mtx
# 0.0,1.0,0.0
# 0.0,0.0,2.0
# 1.0,0.0,0.0
#
#
# Resident 1 has matched with Hospital 3 (since [1,3] is non-zero) at a preference level of 3.0.
# Resident 2 has matched with Hospital 1 (since [2,1] is non-zero) at a preference level of 1.0.
# Resident 3 has matched with Hospital 2 (since [3,2] is non-zero) at a preference level of 2.0.
# --------------------------------------------------------------------------------------------
m_residencyMatchMain = function(Matrix[Double] R, Matrix[Double] H,Matrix[Double] C )
  return (Matrix[Double] ResidencyMatch)
{

#TODO PLEASE PAY ATTENTION
# in this step we consider that  Residents Matrix is ORDERED   !!!!
# in this step we consider that  Hospital  Matrix is UNORDERED !!!!


print("STARTING Resident Hospital Match");
#TODO set a finite number of maximum iterations so that the execution termiates after maximum iterations.

print("\n")
print("STARTING RESIDENCY MATCH ALGORITHM");
print("READING R  as residents AND H as Hospitals and also C as capacity...");


m = nrow(R)
n = ncol (R)
Capacityrows = nrow(C)

#######################################################################################################
Capacity = matrix(0.0, rows=Capacityrows , cols=1)
Capacity = C;
max_position = colMaxs(Capacity)
#######################################################################################################
# we can consider number of choices for every resident #
#######################################################################################################
ResidencyMatch = matrix(0.0, rows=m, cols=n)
HospitalMatch = matrix(0.0, rows=n, cols=m)
Result_matrix = matrix(0.0, rows=nrow(R), cols=ncol(R))
########################################################################################################
if(nrow(Capacity) != nrow(H)) {
  print("ERROR: Wrong Input !Capacity indexes is not match with the Number of hospitals ")
  #it means that some hospitals' capacity is not defined.
}# end of if

StarM = matrix(1.0, rows=m, cols=1)  ### for checking while

HIndex =matrix(1.0, rows=m, cols=1)
proposer_pointers = matrix(1.0, rows=m, cols=1)
prev_Residents_vector = matrix(1.0, rows=n, cols=1)
prevIndex_Residents_vector = matrix(1.0, rows=n, cols=1)

prev_Residents_vector = rowMins(HospitalMatch)
prevIndex_Residents_vector =  rowIndexMin(HospitalMatch)

while(sum(StarM) > 0) {

  for(i in 1:m) {

    while (as.scalar (StarM[i]) == 1)  {
      SecondIndex = as.scalar (proposer_pointers[i])
      HIndex[i] = as.scalar (R[i,SecondIndex])
      prev_Residents_vector = rowMaxs(HospitalMatch) # we consider if the preference value is 1 it means it is the first selection of that hospital, the minimum value means most preference.
      prevIndex_Residents_vector =  rowIndexMax(HospitalMatch)
      if (as.scalar(HIndex[i]) != 0 ){

        HosValue = as.scalar (H[as.scalar (HIndex[i]),i])
        if (HosValue > 0){
          ##################### if this hospital likes this resident and has the capacity ...
          if (as.scalar (Capacity[as.scalar (HIndex[i]),1]) >= 1){
            Capacity[as.scalar (HIndex[i]),1] = as.scalar (Capacity[as.scalar (HIndex[i]),1]) -1
            ResidencyMatch [i,as.scalar (HIndex[i])] = as.scalar (proposer_pointers[i])
            HospitalMatch [as.scalar (HIndex[i]), i] = HosValue
            #Disable freshly Matched resident to search for a new Hospital in the next round
            StarM[i] =0
            proposer_pointers[i] = as.scalar(proposer_pointers[i]) + 1
            if (as.scalar(proposer_pointers[i]) > n){
              proposer_pointers[i] = n
            }

          }# #########end of  if (as.scalar(HIndex[i]) != 0 )##########################

          else if  (as.scalar (Capacity[as.scalar (HIndex[i]),1]) < 1) {

            if   ((as.scalar (prev_Residents_vector[as.scalar (HIndex[i])]))>= SecondIndex  ){

              ##### in this step we check that if the hospital capacity is 0 but the preference value of  prev residents is lower than the preference value of current resident #######
              ##### we should replace the prev resident with current resident----------------------------------------------------------------------------------------------------#######
              HXX= as.scalar(prevIndex_Residents_vector[as.scalar (HIndex[i]),1])     #############which prev resident should be removed
              HospitalMatch [as.scalar (HIndex[i]) ,HXX] = 0
              ResidencyMatch[HXX,as.scalar (HIndex[i])] = 0
              HospitalMatch [as.scalar (HIndex[i]),i ] = as.scalar (proposer_pointers[i])
              ResidencyMatch [i,as.scalar (HIndex[i])] = as.scalar (proposer_pointers[i])
              StarM[i] =0
              prevResIndex =as.scalar(prevIndex_Residents_vector[as.scalar (HIndex[i]),1])
              if(prevResIndex  > 0){
                StarM[prevResIndex ] =1
                proposer_pointers[i] = as.scalar(proposer_pointers[i]) + 1
                if (as.scalar(proposer_pointers[i]) > n){
                  proposer_pointers[i] = n
                }
              }# end of  if(prevResIndex  > 0)
            }# end of checking secondIndex
          }## end of else if
        } #end of if X

        if ( as.scalar (StarM[i]) == 1 ){
          proposer_pointers[i] = as.scalar(proposer_pointers[i]) + 1
          if (as.scalar(proposer_pointers[i]) > n){
            proposer_pointers[i] = n
          }
        }###end else if hosvalue
      }# end of if   if (as.scalar(HIndex[i])
      #  new_best_proposer_index = i
    }
  } ##  end of for (i 1:m)
}   # end of while

print("ResidencyMatch")
print(toString(ResidencyMatch))
print("HospitalMatch")
print(toString(HospitalMatch))
}